<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>durak_env API documentation</title>
<meta name="description" content="A Gym environment that mimics a game of Durak â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>durak_env</code></h1>
</header>
<section id="section-intro">
<p>A Gym environment that mimics a game of Durak.</p>
<p>Contains the DurakEnv class, which is a child class of the gym.Env class.
Implements all of the functions necessary to play through a game of Durak and
train a machine learning model to play it.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A Gym environment that mimics a game of Durak.

Contains the DurakEnv class, which is a child class of the gym.Env class.
Implements all of the functions necessary to play through a game of Durak and
train a machine learning model to play it.
&#34;&#34;&#34;

import logging
import random

# pylint: disable=import-error
import gym
import numpy as np
from gym import spaces

from card import Card, CARDS, RANK_NUM
from deck import Deck
from player import Player
from strategy import Attack, Defense, S0, S1, S2, StratRandom

# logging.basicConfig(level=logging.INFO)

# Constants
PRODUCTS = [&#39;a&#39;, &#39;d&#39;, &#39;s&#39;]
SUMS = [&#39;done&#39;, &#39;take&#39;]
TOTAL_OPTIONS = len(CARDS) + len([&#39;done&#39;, &#39;take&#39;])

OPTIONS_DICT = {}
TOTAL = 0
for c in CARDS:
    OPTIONS_DICT[TOTAL] = c
    TOTAL += 1

OPTIONS_DICT[TOTAL] = &#39;done&#39;
TOTAL += 1
OPTIONS_DICT[TOTAL] = &#39;take&#39;
CARD_TO_OBS = {card: i for i, card in enumerate(CARDS)}

logging.debug(&#34;%s&#34;, OPTIONS_DICT)
logging.debug(&#34;%s&#34;, len(OPTIONS_DICT))
logging.debug(&#34;%s&#34;, OPTIONS_DICT[35])
logging.debug(&#34;%s&#34;, TOTAL_OPTIONS)
logging.debug(&#34;%s %s&#34;, 35, OPTIONS_DICT[35])
logging.debug(&#34;%s %s&#34;, 36, OPTIONS_DICT[36])
logging.debug(&#34;%s %s&#34;, 37, OPTIONS_DICT[37])

WIN = &#39;W&#39;
LOSE = &#39;L&#39;
CONTINUE = &#39;C&#39;


class Model:
    &#34;&#34;&#34;Model is a wrapper for the AI hand.

        Attributes:
            hand: The cards in the model&#39;s hand.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Inits Model.
        &#34;&#34;&#34;

        self.hand = []

    def __len__(self):
        return len(self.hand)

    def take(self, card):
        &#34;&#34;&#34;Adds card to the model&#39;s hand.

        Args:
            card: The card to add to the hand.
        &#34;&#34;&#34;

        if card is not None:
            self.hand.append(card)

    def take_table(self, cards):
        &#34;&#34;&#34;Adds cards to the model&#39;s hand.

        Args:
            cards: The list of cards to add to the model&#39;s hand.
        &#34;&#34;&#34;

        self.hand += cards

    def remove_card(self, card):
        &#34;&#34;&#34;Removes a card from the model&#39;s hand.

        Args:
            card: The card to remove from the model&#39;s hand.
        &#34;&#34;&#34;

        self.hand.remove(card)


class DurakEnv(gym.Env):
    &#34;&#34;&#34;The environment that represents a game of Durak.

    Durak is a Russian/Slavic/Eastern European card game that
    exists somewhere in between War and Euchre. Rounds are played with
    attackers and defenders, the first to go out wins, and the trump &#39;dank&#39;
    suit matters. It&#39;s a good blend of mechanics, strategy, and luck.

    Attributes:
        action_space: The set of available actions.
        observation_space: The set of variables in the environment.
        game_started: Whether or not the game has been started.
        deck: Deck object containing cards.
        out_pile: List of cards that are out of the game.
        players: The number of players.
        turns: The number of turns taken so far.
        table: The cards on the current attack/defense.
        ranks: Hash table of ranks of cards in table.
        attack_count: Count of attacks this turn.
        state: String representing the state of the game DFA.
        dank: String representing the dank suit.
        table_card: Card at the bottom of the deck.
        strategies: The list of strategies that may be randomly chosen.
        opponent: Bot that plays against the Model.
        print_trace: Whether or not to print trace of the game.
        first_shed: True if first shed of the turn, false otherwise.
        shed_so_far: Number of cards shed so far.
        allowed_to_shed: Total number of cards the Model could shed.
        model: Model object wrapper, mostly manages Model&#39;s hand.
        legal_moves: The count of legal moves the model has done.
        successful_attacks The count of successful attacks the model has done.
        successful_defenses: The count of successful defenses the model has done.
        takes: The count of takes the model has done.
        player1: Whether it is player 1&#39;s turn
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Inits DurakEnv.
        &#34;&#34;&#34;

        super(DurakEnv, self).__init__()

        # 36 Cards, Take, Done
        self.action_space = self.action_space = spaces.Box(low=np.array([0] * 38), high=np.array([1] * 38))

        # Bit vector of valid option
        self.observation_space = spaces.MultiDiscrete([1] * 219)

        self.game_started = False
        self.deck = None
        self.out_pile = []
        self.players = []
        self.turns = 0
        self.table = []
        self.ranks = {}
        self.attack_count = 0
        self.state = None
        self.dank = None
        self.table_card = None
        self.strategies = [Player(&#34;Bot&#34;, S0()), Player(&#34;Bot&#34;, S1()), Player(&#34;Bot&#34;, S2()), Player(&#34;Bot&#34;, StratRandom())]
        self.opponent = None
        self.print_trace = False
        self.first_shed = True
        self.shed_so_far = None
        self.allowed_to_shed = None
        self.model = None
        self.legal_moves = 0
        self.successful_attacks = 0
        self.successful_defenses = 0
        self.takes = 0
        self.player1 = True

    def add_attack(self, card):
        &#34;&#34;&#34;Adds card to the table and updates ranks.

        Args:
            card: Card to be added to the table

        Returns:
        &#34;&#34;&#34;

        self.table.append(card)
        self.ranks[card.rank] = 0
        self.attack_count += 1

    def clear_table(self):
        &#34;&#34;&#34;Method to clean up variables related to the table.
        &#34;&#34;&#34;

        self.out_pile += self.table
        self.table = []
        self.ranks = {}
        self.attack_count = 0

    def mandatory_opponent_attack(self, info):
        &#34;&#34;&#34;Bot&#39;s first attack and set state.

        Args:
            info: Error message to raise
        &#34;&#34;&#34;

        atk = self.opponent.attack(self.table, self.ranks)
        if self.print_trace:
            print(&#39;Opponent starts attack with &#39; + str(atk[1]))
        if atk[0] != Attack.play:
            raise RuntimeError(info)
        self.add_attack(atk[1])
        self.state = &#39;d&#39;
        del atk

    def player_draw(self, player):
        &#34;&#34;&#34; Players draw and report win condition.

        Args:
            player: Model or Player.

        Returns:
            True if player is out of cards after draw, False otherwise.
        &#34;&#34;&#34;

        if len(player) &lt; 6:
            for _ in range(6 - len(player)):
                player.take(self.deck.draw())
            if len(player) == 0:
                return True

        return False

    def legal_defense(self, move):
        &#34;&#34;&#34;Determines whether a defense is a legal action or not.

        Args:
            move: The defense to check.

        Returns:
            True if defense is legal.
                Defense is legal if it is higher rank same suit, or any dank, or
                higher dank in the case that a dank was played.
        &#34;&#34;&#34;

        if move == 37:
            # Take is always legal in defense.
            return True

        if move &lt; 36:
            # Made a defense move.
            card = OPTIONS_DICT[move]
            # Defend against attack.
            attack = self.table[-1]
            if card in self.model.hand:
                if card.suit == attack.suit and RANK_NUM[card.rank] &gt; RANK_NUM[attack.rank]:
                    # Higher in same suit, dank or non.
                    return True

                if attack.suit != self.dank and card.suit == self.dank:
                    # Or defense is dank suit and attack is not.
                    return True
        return False

    def legal_shed(self, move):
        &#34;&#34;&#34;Determines whether a shed is a legal action or not.

        Args:
            move: The attack to check.

        Returns:
            Whether or not the shed is legal.
                &#39;Done&#39; is always a legal shed.
                Shed card is legal if card is in hand and rank matches table.
        &#34;&#34;&#34;

        # First shed state of the round.
        if self.first_shed:
            self.first_shed = False
            self.allowed_to_shed = min(6 - self.attack_count, len(self.opponent))
            self.shed_so_far = 0
        # Done is always legal during a shed.
        if move == 36:
            self.first_shed = True
            self.allowed_to_shed = -1
            return True

        # Shed action
        if move &lt; 36:
            card = OPTIONS_DICT[move]
            if card in self.model.hand and card.rank in self.ranks and self.shed_so_far &lt; self.allowed_to_shed:
                self.first_shed = False
                self.shed_so_far += 1
                return True

        return False

    def legal_attack(self, move: int):
        &#34;&#34;&#34;Determines whether an attack is a legal action or not.

        Args:
            move: The attack to check.

        Returns:
            True if attack is legal, False otherwise.
                Attack is legal if:
                Move &lt; 36 or 108.
                Card matches ranks in table.
                Card is in hand.
        &#34;&#34;&#34;

        # Has chosen to play a card.
        if move &lt; 36:
            card = OPTIONS_DICT[move]
            if card in self.model.hand and (card.rank in self.ranks or len(self.table) == 0):
                return True
        # &#39;done&#39;
        elif move == 36:
            if len(self.table) != 0:
                return True
        return False

    def step(self, action: list):
        &#34;&#34;&#34;Proceeds through a single step in the game.

        Goes from one state of the game to the next based on the input action
        that it receives and returns relevant information.
        detail.

        Args:
            action: The action to take on this step.

        Returns:
            A representation of the current state of the game,
            a representation ofs the fitness of this genome,
            a representation of whether or not the game is done,
            additional information that may be useful.
        &#34;&#34;&#34;

        if not self.game_started:
            self.game_started = True
            self.deck.shuffle_deck()
            # Deal cards.
            for _ in range(6):
                self.opponent.take(self.deck.draw())
                self.model.take(self.deck.draw())

            self.table_card = self.deck.flip()
            self.dank = self.table_card.suit
            self.opponent.dank = self.dank

            # AI attacks first.
            if action[0] &lt; .5:
                self.state = &#34;a&#34;
                logging.info(&#39;Model attacks first&#39;)
                return self.gen_return(CONTINUE)

            logging.info(&#39;bot attacks first&#39;)
            # Bot attacks first.
            self.mandatory_opponent_attack(info=&#34;Atk[0] != Attack.play, bot is not attacking at start.&#34;)
            return self.gen_return(CONTINUE)

        legal_moves = self.gen_legal_moves()

        filtered = np.multiply(np.array(legal_moves), np.abs((np.array(action)) + .01))

        filtered_action = int(np.argmax(filtered))
        assert isinstance(filtered_action, int)
        move = OPTIONS_DICT[filtered_action]
        self.legal_moves += 1
        if self.state == &#39;a&#39;:
            if self.legal_attack(filtered_action):
                # AI plays a card.
                if isinstance(move, Card):
                    self.model.remove_card(move)
                    self.add_attack(move)
                    defense = self.opponent.defend(self.table, False, 1)
                    # Both players still have cards or drawing potential.
                    logging.info(defense[0])
                    if defense[0] == Defense.defend:
                        self.table += defense[1]
                        self.ranks.update({card.rank: 0 for card in defense[1]})
                        logging.info(&#39;Table object: %s&#39;, &#39;, &#39;.join([str(x) for x in self.table]))
                        # Check for end of turn conditions.
                        if len(self.table) == 12 or len(self.model) == 0 or len(self.opponent) == 0:
                            # Turn is over, reset table.
                            self.clear_table()

                            # Draw cards, attacker then defender
                            if self.player_draw(self.model):
                                # Model wins on attack.
                                return self.gen_return(WIN)

                            if self.player_draw(self.opponent):
                                # Bot wins defending in attack phase.
                                return self.gen_return(LOSE)

                            # Bot attacks table.
                            self.mandatory_opponent_attack(&#39;Opponent is not attacking on first attack after turn end&#39;)
                            return self.gen_return(CONTINUE)
                        # Turn is not over, Model is attacking again
                        self.state = &#39;a&#39;
                        return self.gen_return(CONTINUE)
                    if defense[0] == Defense.take:
                        self.state = &#39;s&#39;  # Model will be shedding in next step
                        if self.print_trace:
                            print(&#39;Opponent has chosen to take&#39;)
                        self.successful_attacks += 1
                        return self.gen_return(CONTINUE)
                    raise RuntimeError(&#39;Opponent has passed cards&#39;)
                if move == &#39;done&#39;:  # AI is done in attack context
                    self.clear_table()
                    # Bot attacks table.
                    if self.player_draw(self.model):
                        # MODEL win, impossible condition.
                        raise RuntimeError(&#34;Win condition: Model won during done&#34;)
                    if self.player_draw(self.opponent):
                        # Opponent win, impossible condition.
                        raise RuntimeError(&#34;Win condition: Opponent won during done&#34;)
                    self.mandatory_opponent_attack(&#39;Opponent is not attacking on first attack.&#39;)
                    logging.info(&#39;Bot attack after done&#39;)
                    logging.info(&#39; &#39;.join([str(x) for x in self.table]))
                    # Model will be defending next turn.
                    return self.gen_return(CONTINUE)
                raise RuntimeError(&#39;Legal_attack true but not attack or move.&#39;)
            # Punish and end.
            logging.error(&#39;Model has played illegal move&#39;)
            logging.error(str(move))
            logging.error(&#39;move %s&#39;, move)
            logging.error(&#39;filtered actions: %s&#39;, filtered)
            logging.info(&#39;legal_attack %s&#39;, self.legal_attack(filtered_action))
            raise RuntimeError(&#34;Model made an illegal move&#34;)
        # Defend state logic.
        if self.state == &#34;d&#34;:
            # Bot has already attacked.
            if self.legal_defense(filtered_action):
                if isinstance(move, Card):
                    self.table.append(move)
                    self.model.remove_card(move)
                    if len(self.table) == 12 or len(self.model) == 0 or len(self.opponent) == 0:
                        # Turn is over
                        self.clear_table()
                        # Draw cards, attacker (opponent) then defender (model)
                        if self.player_draw(self.opponent):
                            # Bot wins defending in attack phase.
                            return self.gen_return(LOSE)
                        if self.player_draw(self.model):
                            # Model wins on attack.
                            return self.gen_return(WIN)
                        # If game hasn&#39;t ended, the turn is over and the bot successfully defends.
                        self.state = &#34;a&#34;
                        return self.gen_return(CONTINUE)

                    atk = self.opponent.attack(self.table, self.ranks)
                    logging.info(atk[0])
                    if atk[0] == Attack.play:
                        self.add_attack(atk[1])
                        self.state = &#39;d&#39;
                        return self.gen_return(CONTINUE)

                    if atk[0] == Attack.done:
                        self.clear_table()
                        # Players get to draw, attacker first.
                        # It shouldn&#39;t be possible for a win condition here.
                        if self.player_draw(self.opponent):
                            raise RuntimeError(&#39;Win condition in defense phase:\nOpponent has won after ceasing attack.&#39;)

                        if self.player_draw(self.model):
                            raise RuntimeError(&#39;Win condition in defense phase:\nModel has won after ceasing attack.&#39;)

                        self.successful_defenses += 1
                        self.state = &#39;a&#39;
                    else:

                        raise RuntimeError(&#39;In defense phase, opponent has not chosen play or done.&#39;)

                elif move == &#39;take&#39;:
                    # Bot gets to shed.
                    self.takes += 1
                    shed = self.opponent.shed(self.table, min((6 - self.attack_count, len(self.model))), self.ranks)
                    if self.print_trace:
                        print(&#34;opponent sheds: &#34; + &#34;, &#34;.join([str(x) for x in shed]))

                    if self.player_draw(self.opponent):
                        # Opponent has won on their shed.
                        return self.gen_return(LOSE)

                    self.table += shed
                    self.model.take_table(self.table)
                    # self.table = [] before clear table to prevent out pile duplicate.
                    self.table = []
                    self.clear_table()

                    # Get Bot Attack.
                    self.mandatory_opponent_attack(&#39;opponent is not attacking on first attack&#39;)
                else:
                    raise RuntimeError(&#39;legal_defense true but not defense or take: move = {}&#39;.format(str(move)))
            else:
                # Return and punish.
                logging.error(&#39;Model has played illegal move&#39;)
                logging.error(str(move))
                logging.error(&#39;move %s&#39;, move)
                logging.error(&#39;filtered actions: %s&#39;, filtered)
                logging.error(&#39;action %s&#39;, filtered_action)
                logging.info(&#39;legal_Defense %s&#39;, self.legal_defense(filtered_action))
                raise RuntimeError(&#34;Model made an illegal move&#34;)

        # Shed state logic.
        elif self.state == &#34;s&#34;:
            logging.info(&#39;state s&#39;)
            if self.legal_shed(filtered_action):
                if isinstance(move, Card):
                    # Shed 1 card -&gt; return to shed.
                    self.model.remove_card(move)
                    self.add_attack(move)
                    self.state = &#39;s&#39;
                elif move == &#39;done&#39;:
                    # Done -&gt; attack.
                    self.first_shed = True
                    self.opponent.take_table(self.table)

                    # self.table = [] before clear table to prevent duplicates in out pile
                    self.table = []
                    self.clear_table()
                    self.state = &#39;a&#39;

                    # Check win condition / draw.
                    # Opponent shouldn&#39;t have to draw here.
                    if self.player_draw(self.model):
                        # Model has won by shedding last cards.
                        return self.gen_return(WIN)
                    return self.gen_return(CONTINUE)

                else:
                    logging.info(&#39;move %s&#39;, move)
                    logging.info(&#39;action %s&#39;, filtered_action)
                    raise RuntimeError(&#39;legal_shed true but not shed or done&#39;)
            else:
                logging.error(&#39;Model has played illegal move&#39;)
                logging.error(&#39;Dank %s: &#39;, self.dank)
                logging.error(&#39;Attack Count: %s &#39;, str(self.attack_count))
                logging.error(&#39;shed so far %s &#39;, str(self.shed_so_far))
                logging.error(&#39;Table: %s&#39;, str([str(x) for x in self.table]))
                logging.error(&#39;Hand: %s&#39;, str([str(x) for x in self.model.hand]))
                logging.error(&#39;len opponent %s&#39;, str(len(self.opponent)))
                logging.error(str(move))
                logging.error(&#39;move %s&#39;, move)
                logging.error(&#39;filtered actions: %s&#39;, list(filtered))
                logging.info(&#39;legal_attack %s&#39;, self.legal_attack(filtered_action))
                raise RuntimeError(&#34;Model made an illegal move&#34;)

        logging.info(&#34;%s&#34;, self.state)

        return self.gen_return(CONTINUE)

    def gen_legal_moves(self):
        &#34;&#34;&#34;Generates a set of legal moves.

        Returns:
            Boolean vector of legal moves.
        &#34;&#34;&#34;

        ret = [0] * 38
        if self.state == &#39;a&#39;:
            if len(self.table) != 0:
                ret[36] = 1
            for card in self.model.hand:
                if self.legal_attack(CARD_TO_OBS[card]):
                    ret[CARD_TO_OBS[card]] = 1

        if self.state == &#39;d&#39;:
            ret[37] = 1
            for card in self.model.hand:
                if self.legal_defense(CARD_TO_OBS[card]):
                    ret[CARD_TO_OBS[card]] = 1

        # legal_shed called AFTER
        if self.state == &#39;s&#39;:
            ret[36] = 1
            if self.first_shed:
                allowed_sheds = min(6 - self.attack_count, len(self.opponent))
                if allowed_sheds &gt; 0:
                    for card in self.model.hand:
                        if card.rank in self.ranks:
                            ret[CARD_TO_OBS[card]] = 1
            else:
                if self.shed_so_far &lt; self.allowed_to_shed:
                    for card in self.model.hand:
                        if card.rank in self.ranks:
                            ret[CARD_TO_OBS[card]] = 1

        return ret

    def gen_obs(self, condition):
        &#34;&#34;&#34;Generates observations to send to the model.

        Returns:
            An observation based on game state.
        &#34;&#34;&#34;
        if condition in (WIN, LOSE):
            return np.zeros(219, )
        # 0 if unknown.
        ret = [0] * 36
        # 1 if on table.
        for card in self.table:
            ret[CARD_TO_OBS[card]] = 1
        # 2 if in hand.
        for card in self.model.hand:
            ret[CARD_TO_OBS[card]] = 2

        # 3 if in out pile.
        for card in self.out_pile:
            ret[CARD_TO_OBS[card]] = 3

        # 4 if table card.
        ret[CARD_TO_OBS[self.table_card]] = 4
        ret2 = np.zeros(shape=(6, 36), )
        state = [0, 0, 0]
        if self.state == &#39;a&#39;:
            state[0] = 1
        elif self.state == &#39;s&#39;:
            state[1] = 1
        elif self.state == &#39;d&#39;:
            state[2] = 1
            last_card = self.table[-1]
            obs = CARD_TO_OBS[last_card]
            ret2[5][obs] = 1

        for index, value in enumerate(ret):
            ret2[value][index] = 1

        return np.concatenate((ret2.flatten(), state))

    def gen_info(self, condition):
        &#34;&#34;&#34;Generates info to return.

        Args:
            condition: WIN, LOSE, or CONTINUE.

        Returns:
            The number of takes, legal moves, successful attacks and defends,
            and the end condition.
        &#34;&#34;&#34;

        if condition == WIN:
            end_condition = &#39;WIN&#39;
        elif condition == LOSE:
            end_condition = &#39;LOSE&#39;
        else:
            end_condition = &#39;N/A&#39;
        return {&#39;takes&#39;: self.takes, &#39;legal_moves&#39;: self.legal_moves, &#39;successful_attacks&#39;: self.successful_attacks, &#39;successful_defends&#39;: self.successful_defenses, &#39;end_condition&#39;: end_condition, &#39;player1&#39;: self.player1}

    def gen_return(self, condition):
        &#34;&#34;&#34;Generates all 4 return objects.

        Args:
            condition: WIN or LOSS

        Returns:
            The observation, the reward, whether the run is done, and the info.
        &#34;&#34;&#34;

        bonus = 10 if condition == WIN else 0
        done = bool(condition in (WIN, LOSE))
        return self.gen_obs(condition), bonus, done, self.gen_info(condition)

    # def gen_score(self):
    #     &#34;&#34;&#34;Generates a reward to return.
    #     &#34;&#34;&#34;
    #     # Hand value calculation
    #     # hand_value = sum([dank_float_order(card, self.dank) for card in self.model.hand])
    #     # hand_value = hand_value / (len(self.model.hand) + 1) * 8
    #     # # Punishes for excessive taking.
    #     # taking_reward = 2 / 3.1415 * 3.5 * atan(4 - self.takes)
    #
    #     return 0

    def reset(self):
        &#34;&#34;&#34;Resets the game to the starting state.
        &#34;&#34;&#34;

        self.game_started = False
        self.deck = Deck()
        self.out_pile = []
        self.players = []
        self.turns = 0
        self.table = []
        self.ranks = {}
        self.attack_count = 0
        self.state = None
        self.dank = None
        self.table_card = None
        self.opponent = random.choice(self.strategies)
        self.first_shed = True
        self.shed_so_far = None
        self.allowed_to_shed = None
        self.model = Model()
        self.legal_moves = 0
        self.successful_attacks = 0
        self.successful_defenses = 0
        self.takes = 0
        self.player1 = True

    def render(self, mode=&#39;human&#39;):
        &#34;&#34;&#34;Will not be used.
        &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="durak_env.DurakEnv"><code class="flex name class">
<span>class <span class="ident">DurakEnv</span></span>
</code></dt>
<dd>
<section class="desc"><p>The environment that represents a game of Durak.</p>
<p>Durak is a Russian/Slavic/Eastern European card game that
exists somewhere in between War and Euchre. Rounds are played with
attackers and defenders, the first to go out wins, and the trump 'dank'
suit matters. It's a good blend of mechanics, strategy, and luck.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>action_space</code></strong></dt>
<dd>The set of available actions.</dd>
<dt><strong><code>observation_space</code></strong></dt>
<dd>The set of variables in the environment.</dd>
<dt><strong><code>game_started</code></strong></dt>
<dd>Whether or not the game has been started.</dd>
<dt><strong><a title="deck" href="deck.html"><code>deck</code></a></strong></dt>
<dd>Deck object containing cards.</dd>
<dt><strong><code>out_pile</code></strong></dt>
<dd>List of cards that are out of the game.</dd>
<dt><strong><code>players</code></strong></dt>
<dd>The number of players.</dd>
<dt><strong><code>turns</code></strong></dt>
<dd>The number of turns taken so far.</dd>
<dt><strong><code>table</code></strong></dt>
<dd>The cards on the current attack/defense.</dd>
<dt><strong><code>ranks</code></strong></dt>
<dd>Hash table of ranks of cards in table.</dd>
<dt><strong><code>attack_count</code></strong></dt>
<dd>Count of attacks this turn.</dd>
<dt><strong><code>state</code></strong></dt>
<dd>String representing the state of the game DFA.</dd>
<dt><strong><code>dank</code></strong></dt>
<dd>String representing the dank suit.</dd>
<dt><strong><code>table_card</code></strong></dt>
<dd>Card at the bottom of the deck.</dd>
<dt><strong><code>strategies</code></strong></dt>
<dd>The list of strategies that may be randomly chosen.</dd>
<dt><strong><code>opponent</code></strong></dt>
<dd>Bot that plays against the Model.</dd>
<dt><strong><code>print_trace</code></strong></dt>
<dd>Whether or not to print trace of the game.</dd>
<dt><strong><code>first_shed</code></strong></dt>
<dd>True if first shed of the turn, false otherwise.</dd>
<dt><strong><code>shed_so_far</code></strong></dt>
<dd>Number of cards shed so far.</dd>
<dt><strong><code>allowed_to_shed</code></strong></dt>
<dd>Total number of cards the Model could shed.</dd>
<dt><strong><code>model</code></strong></dt>
<dd>Model object wrapper, mostly manages Model's hand.</dd>
<dt><strong><code>legal_moves</code></strong></dt>
<dd>The count of legal moves the model has done.</dd>
<dt>successful_attacks The count of successful attacks the model has done.</dt>
<dt><strong><code>successful_defenses</code></strong></dt>
<dd>The count of successful defenses the model has done.</dd>
<dt><strong><code>takes</code></strong></dt>
<dd>The count of takes the model has done.</dd>
<dt><strong><code>player1</code></strong></dt>
<dd>Whether it is player 1's turn</dd>
</dl>
<p>Inits DurakEnv.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DurakEnv(gym.Env):
    &#34;&#34;&#34;The environment that represents a game of Durak.

    Durak is a Russian/Slavic/Eastern European card game that
    exists somewhere in between War and Euchre. Rounds are played with
    attackers and defenders, the first to go out wins, and the trump &#39;dank&#39;
    suit matters. It&#39;s a good blend of mechanics, strategy, and luck.

    Attributes:
        action_space: The set of available actions.
        observation_space: The set of variables in the environment.
        game_started: Whether or not the game has been started.
        deck: Deck object containing cards.
        out_pile: List of cards that are out of the game.
        players: The number of players.
        turns: The number of turns taken so far.
        table: The cards on the current attack/defense.
        ranks: Hash table of ranks of cards in table.
        attack_count: Count of attacks this turn.
        state: String representing the state of the game DFA.
        dank: String representing the dank suit.
        table_card: Card at the bottom of the deck.
        strategies: The list of strategies that may be randomly chosen.
        opponent: Bot that plays against the Model.
        print_trace: Whether or not to print trace of the game.
        first_shed: True if first shed of the turn, false otherwise.
        shed_so_far: Number of cards shed so far.
        allowed_to_shed: Total number of cards the Model could shed.
        model: Model object wrapper, mostly manages Model&#39;s hand.
        legal_moves: The count of legal moves the model has done.
        successful_attacks The count of successful attacks the model has done.
        successful_defenses: The count of successful defenses the model has done.
        takes: The count of takes the model has done.
        player1: Whether it is player 1&#39;s turn
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Inits DurakEnv.
        &#34;&#34;&#34;

        super(DurakEnv, self).__init__()

        # 36 Cards, Take, Done
        self.action_space = self.action_space = spaces.Box(low=np.array([0] * 38), high=np.array([1] * 38))

        # Bit vector of valid option
        self.observation_space = spaces.MultiDiscrete([1] * 219)

        self.game_started = False
        self.deck = None
        self.out_pile = []
        self.players = []
        self.turns = 0
        self.table = []
        self.ranks = {}
        self.attack_count = 0
        self.state = None
        self.dank = None
        self.table_card = None
        self.strategies = [Player(&#34;Bot&#34;, S0()), Player(&#34;Bot&#34;, S1()), Player(&#34;Bot&#34;, S2()), Player(&#34;Bot&#34;, StratRandom())]
        self.opponent = None
        self.print_trace = False
        self.first_shed = True
        self.shed_so_far = None
        self.allowed_to_shed = None
        self.model = None
        self.legal_moves = 0
        self.successful_attacks = 0
        self.successful_defenses = 0
        self.takes = 0
        self.player1 = True

    def add_attack(self, card):
        &#34;&#34;&#34;Adds card to the table and updates ranks.

        Args:
            card: Card to be added to the table

        Returns:
        &#34;&#34;&#34;

        self.table.append(card)
        self.ranks[card.rank] = 0
        self.attack_count += 1

    def clear_table(self):
        &#34;&#34;&#34;Method to clean up variables related to the table.
        &#34;&#34;&#34;

        self.out_pile += self.table
        self.table = []
        self.ranks = {}
        self.attack_count = 0

    def mandatory_opponent_attack(self, info):
        &#34;&#34;&#34;Bot&#39;s first attack and set state.

        Args:
            info: Error message to raise
        &#34;&#34;&#34;

        atk = self.opponent.attack(self.table, self.ranks)
        if self.print_trace:
            print(&#39;Opponent starts attack with &#39; + str(atk[1]))
        if atk[0] != Attack.play:
            raise RuntimeError(info)
        self.add_attack(atk[1])
        self.state = &#39;d&#39;
        del atk

    def player_draw(self, player):
        &#34;&#34;&#34; Players draw and report win condition.

        Args:
            player: Model or Player.

        Returns:
            True if player is out of cards after draw, False otherwise.
        &#34;&#34;&#34;

        if len(player) &lt; 6:
            for _ in range(6 - len(player)):
                player.take(self.deck.draw())
            if len(player) == 0:
                return True

        return False

    def legal_defense(self, move):
        &#34;&#34;&#34;Determines whether a defense is a legal action or not.

        Args:
            move: The defense to check.

        Returns:
            True if defense is legal.
                Defense is legal if it is higher rank same suit, or any dank, or
                higher dank in the case that a dank was played.
        &#34;&#34;&#34;

        if move == 37:
            # Take is always legal in defense.
            return True

        if move &lt; 36:
            # Made a defense move.
            card = OPTIONS_DICT[move]
            # Defend against attack.
            attack = self.table[-1]
            if card in self.model.hand:
                if card.suit == attack.suit and RANK_NUM[card.rank] &gt; RANK_NUM[attack.rank]:
                    # Higher in same suit, dank or non.
                    return True

                if attack.suit != self.dank and card.suit == self.dank:
                    # Or defense is dank suit and attack is not.
                    return True
        return False

    def legal_shed(self, move):
        &#34;&#34;&#34;Determines whether a shed is a legal action or not.

        Args:
            move: The attack to check.

        Returns:
            Whether or not the shed is legal.
                &#39;Done&#39; is always a legal shed.
                Shed card is legal if card is in hand and rank matches table.
        &#34;&#34;&#34;

        # First shed state of the round.
        if self.first_shed:
            self.first_shed = False
            self.allowed_to_shed = min(6 - self.attack_count, len(self.opponent))
            self.shed_so_far = 0
        # Done is always legal during a shed.
        if move == 36:
            self.first_shed = True
            self.allowed_to_shed = -1
            return True

        # Shed action
        if move &lt; 36:
            card = OPTIONS_DICT[move]
            if card in self.model.hand and card.rank in self.ranks and self.shed_so_far &lt; self.allowed_to_shed:
                self.first_shed = False
                self.shed_so_far += 1
                return True

        return False

    def legal_attack(self, move: int):
        &#34;&#34;&#34;Determines whether an attack is a legal action or not.

        Args:
            move: The attack to check.

        Returns:
            True if attack is legal, False otherwise.
                Attack is legal if:
                Move &lt; 36 or 108.
                Card matches ranks in table.
                Card is in hand.
        &#34;&#34;&#34;

        # Has chosen to play a card.
        if move &lt; 36:
            card = OPTIONS_DICT[move]
            if card in self.model.hand and (card.rank in self.ranks or len(self.table) == 0):
                return True
        # &#39;done&#39;
        elif move == 36:
            if len(self.table) != 0:
                return True
        return False

    def step(self, action: list):
        &#34;&#34;&#34;Proceeds through a single step in the game.

        Goes from one state of the game to the next based on the input action
        that it receives and returns relevant information.
        detail.

        Args:
            action: The action to take on this step.

        Returns:
            A representation of the current state of the game,
            a representation ofs the fitness of this genome,
            a representation of whether or not the game is done,
            additional information that may be useful.
        &#34;&#34;&#34;

        if not self.game_started:
            self.game_started = True
            self.deck.shuffle_deck()
            # Deal cards.
            for _ in range(6):
                self.opponent.take(self.deck.draw())
                self.model.take(self.deck.draw())

            self.table_card = self.deck.flip()
            self.dank = self.table_card.suit
            self.opponent.dank = self.dank

            # AI attacks first.
            if action[0] &lt; .5:
                self.state = &#34;a&#34;
                logging.info(&#39;Model attacks first&#39;)
                return self.gen_return(CONTINUE)

            logging.info(&#39;bot attacks first&#39;)
            # Bot attacks first.
            self.mandatory_opponent_attack(info=&#34;Atk[0] != Attack.play, bot is not attacking at start.&#34;)
            return self.gen_return(CONTINUE)

        legal_moves = self.gen_legal_moves()

        filtered = np.multiply(np.array(legal_moves), np.abs((np.array(action)) + .01))

        filtered_action = int(np.argmax(filtered))
        assert isinstance(filtered_action, int)
        move = OPTIONS_DICT[filtered_action]
        self.legal_moves += 1
        if self.state == &#39;a&#39;:
            if self.legal_attack(filtered_action):
                # AI plays a card.
                if isinstance(move, Card):
                    self.model.remove_card(move)
                    self.add_attack(move)
                    defense = self.opponent.defend(self.table, False, 1)
                    # Both players still have cards or drawing potential.
                    logging.info(defense[0])
                    if defense[0] == Defense.defend:
                        self.table += defense[1]
                        self.ranks.update({card.rank: 0 for card in defense[1]})
                        logging.info(&#39;Table object: %s&#39;, &#39;, &#39;.join([str(x) for x in self.table]))
                        # Check for end of turn conditions.
                        if len(self.table) == 12 or len(self.model) == 0 or len(self.opponent) == 0:
                            # Turn is over, reset table.
                            self.clear_table()

                            # Draw cards, attacker then defender
                            if self.player_draw(self.model):
                                # Model wins on attack.
                                return self.gen_return(WIN)

                            if self.player_draw(self.opponent):
                                # Bot wins defending in attack phase.
                                return self.gen_return(LOSE)

                            # Bot attacks table.
                            self.mandatory_opponent_attack(&#39;Opponent is not attacking on first attack after turn end&#39;)
                            return self.gen_return(CONTINUE)
                        # Turn is not over, Model is attacking again
                        self.state = &#39;a&#39;
                        return self.gen_return(CONTINUE)
                    if defense[0] == Defense.take:
                        self.state = &#39;s&#39;  # Model will be shedding in next step
                        if self.print_trace:
                            print(&#39;Opponent has chosen to take&#39;)
                        self.successful_attacks += 1
                        return self.gen_return(CONTINUE)
                    raise RuntimeError(&#39;Opponent has passed cards&#39;)
                if move == &#39;done&#39;:  # AI is done in attack context
                    self.clear_table()
                    # Bot attacks table.
                    if self.player_draw(self.model):
                        # MODEL win, impossible condition.
                        raise RuntimeError(&#34;Win condition: Model won during done&#34;)
                    if self.player_draw(self.opponent):
                        # Opponent win, impossible condition.
                        raise RuntimeError(&#34;Win condition: Opponent won during done&#34;)
                    self.mandatory_opponent_attack(&#39;Opponent is not attacking on first attack.&#39;)
                    logging.info(&#39;Bot attack after done&#39;)
                    logging.info(&#39; &#39;.join([str(x) for x in self.table]))
                    # Model will be defending next turn.
                    return self.gen_return(CONTINUE)
                raise RuntimeError(&#39;Legal_attack true but not attack or move.&#39;)
            # Punish and end.
            logging.error(&#39;Model has played illegal move&#39;)
            logging.error(str(move))
            logging.error(&#39;move %s&#39;, move)
            logging.error(&#39;filtered actions: %s&#39;, filtered)
            logging.info(&#39;legal_attack %s&#39;, self.legal_attack(filtered_action))
            raise RuntimeError(&#34;Model made an illegal move&#34;)
        # Defend state logic.
        if self.state == &#34;d&#34;:
            # Bot has already attacked.
            if self.legal_defense(filtered_action):
                if isinstance(move, Card):
                    self.table.append(move)
                    self.model.remove_card(move)
                    if len(self.table) == 12 or len(self.model) == 0 or len(self.opponent) == 0:
                        # Turn is over
                        self.clear_table()
                        # Draw cards, attacker (opponent) then defender (model)
                        if self.player_draw(self.opponent):
                            # Bot wins defending in attack phase.
                            return self.gen_return(LOSE)
                        if self.player_draw(self.model):
                            # Model wins on attack.
                            return self.gen_return(WIN)
                        # If game hasn&#39;t ended, the turn is over and the bot successfully defends.
                        self.state = &#34;a&#34;
                        return self.gen_return(CONTINUE)

                    atk = self.opponent.attack(self.table, self.ranks)
                    logging.info(atk[0])
                    if atk[0] == Attack.play:
                        self.add_attack(atk[1])
                        self.state = &#39;d&#39;
                        return self.gen_return(CONTINUE)

                    if atk[0] == Attack.done:
                        self.clear_table()
                        # Players get to draw, attacker first.
                        # It shouldn&#39;t be possible for a win condition here.
                        if self.player_draw(self.opponent):
                            raise RuntimeError(&#39;Win condition in defense phase:\nOpponent has won after ceasing attack.&#39;)

                        if self.player_draw(self.model):
                            raise RuntimeError(&#39;Win condition in defense phase:\nModel has won after ceasing attack.&#39;)

                        self.successful_defenses += 1
                        self.state = &#39;a&#39;
                    else:

                        raise RuntimeError(&#39;In defense phase, opponent has not chosen play or done.&#39;)

                elif move == &#39;take&#39;:
                    # Bot gets to shed.
                    self.takes += 1
                    shed = self.opponent.shed(self.table, min((6 - self.attack_count, len(self.model))), self.ranks)
                    if self.print_trace:
                        print(&#34;opponent sheds: &#34; + &#34;, &#34;.join([str(x) for x in shed]))

                    if self.player_draw(self.opponent):
                        # Opponent has won on their shed.
                        return self.gen_return(LOSE)

                    self.table += shed
                    self.model.take_table(self.table)
                    # self.table = [] before clear table to prevent out pile duplicate.
                    self.table = []
                    self.clear_table()

                    # Get Bot Attack.
                    self.mandatory_opponent_attack(&#39;opponent is not attacking on first attack&#39;)
                else:
                    raise RuntimeError(&#39;legal_defense true but not defense or take: move = {}&#39;.format(str(move)))
            else:
                # Return and punish.
                logging.error(&#39;Model has played illegal move&#39;)
                logging.error(str(move))
                logging.error(&#39;move %s&#39;, move)
                logging.error(&#39;filtered actions: %s&#39;, filtered)
                logging.error(&#39;action %s&#39;, filtered_action)
                logging.info(&#39;legal_Defense %s&#39;, self.legal_defense(filtered_action))
                raise RuntimeError(&#34;Model made an illegal move&#34;)

        # Shed state logic.
        elif self.state == &#34;s&#34;:
            logging.info(&#39;state s&#39;)
            if self.legal_shed(filtered_action):
                if isinstance(move, Card):
                    # Shed 1 card -&gt; return to shed.
                    self.model.remove_card(move)
                    self.add_attack(move)
                    self.state = &#39;s&#39;
                elif move == &#39;done&#39;:
                    # Done -&gt; attack.
                    self.first_shed = True
                    self.opponent.take_table(self.table)

                    # self.table = [] before clear table to prevent duplicates in out pile
                    self.table = []
                    self.clear_table()
                    self.state = &#39;a&#39;

                    # Check win condition / draw.
                    # Opponent shouldn&#39;t have to draw here.
                    if self.player_draw(self.model):
                        # Model has won by shedding last cards.
                        return self.gen_return(WIN)
                    return self.gen_return(CONTINUE)

                else:
                    logging.info(&#39;move %s&#39;, move)
                    logging.info(&#39;action %s&#39;, filtered_action)
                    raise RuntimeError(&#39;legal_shed true but not shed or done&#39;)
            else:
                logging.error(&#39;Model has played illegal move&#39;)
                logging.error(&#39;Dank %s: &#39;, self.dank)
                logging.error(&#39;Attack Count: %s &#39;, str(self.attack_count))
                logging.error(&#39;shed so far %s &#39;, str(self.shed_so_far))
                logging.error(&#39;Table: %s&#39;, str([str(x) for x in self.table]))
                logging.error(&#39;Hand: %s&#39;, str([str(x) for x in self.model.hand]))
                logging.error(&#39;len opponent %s&#39;, str(len(self.opponent)))
                logging.error(str(move))
                logging.error(&#39;move %s&#39;, move)
                logging.error(&#39;filtered actions: %s&#39;, list(filtered))
                logging.info(&#39;legal_attack %s&#39;, self.legal_attack(filtered_action))
                raise RuntimeError(&#34;Model made an illegal move&#34;)

        logging.info(&#34;%s&#34;, self.state)

        return self.gen_return(CONTINUE)

    def gen_legal_moves(self):
        &#34;&#34;&#34;Generates a set of legal moves.

        Returns:
            Boolean vector of legal moves.
        &#34;&#34;&#34;

        ret = [0] * 38
        if self.state == &#39;a&#39;:
            if len(self.table) != 0:
                ret[36] = 1
            for card in self.model.hand:
                if self.legal_attack(CARD_TO_OBS[card]):
                    ret[CARD_TO_OBS[card]] = 1

        if self.state == &#39;d&#39;:
            ret[37] = 1
            for card in self.model.hand:
                if self.legal_defense(CARD_TO_OBS[card]):
                    ret[CARD_TO_OBS[card]] = 1

        # legal_shed called AFTER
        if self.state == &#39;s&#39;:
            ret[36] = 1
            if self.first_shed:
                allowed_sheds = min(6 - self.attack_count, len(self.opponent))
                if allowed_sheds &gt; 0:
                    for card in self.model.hand:
                        if card.rank in self.ranks:
                            ret[CARD_TO_OBS[card]] = 1
            else:
                if self.shed_so_far &lt; self.allowed_to_shed:
                    for card in self.model.hand:
                        if card.rank in self.ranks:
                            ret[CARD_TO_OBS[card]] = 1

        return ret

    def gen_obs(self, condition):
        &#34;&#34;&#34;Generates observations to send to the model.

        Returns:
            An observation based on game state.
        &#34;&#34;&#34;
        if condition in (WIN, LOSE):
            return np.zeros(219, )
        # 0 if unknown.
        ret = [0] * 36
        # 1 if on table.
        for card in self.table:
            ret[CARD_TO_OBS[card]] = 1
        # 2 if in hand.
        for card in self.model.hand:
            ret[CARD_TO_OBS[card]] = 2

        # 3 if in out pile.
        for card in self.out_pile:
            ret[CARD_TO_OBS[card]] = 3

        # 4 if table card.
        ret[CARD_TO_OBS[self.table_card]] = 4
        ret2 = np.zeros(shape=(6, 36), )
        state = [0, 0, 0]
        if self.state == &#39;a&#39;:
            state[0] = 1
        elif self.state == &#39;s&#39;:
            state[1] = 1
        elif self.state == &#39;d&#39;:
            state[2] = 1
            last_card = self.table[-1]
            obs = CARD_TO_OBS[last_card]
            ret2[5][obs] = 1

        for index, value in enumerate(ret):
            ret2[value][index] = 1

        return np.concatenate((ret2.flatten(), state))

    def gen_info(self, condition):
        &#34;&#34;&#34;Generates info to return.

        Args:
            condition: WIN, LOSE, or CONTINUE.

        Returns:
            The number of takes, legal moves, successful attacks and defends,
            and the end condition.
        &#34;&#34;&#34;

        if condition == WIN:
            end_condition = &#39;WIN&#39;
        elif condition == LOSE:
            end_condition = &#39;LOSE&#39;
        else:
            end_condition = &#39;N/A&#39;
        return {&#39;takes&#39;: self.takes, &#39;legal_moves&#39;: self.legal_moves, &#39;successful_attacks&#39;: self.successful_attacks, &#39;successful_defends&#39;: self.successful_defenses, &#39;end_condition&#39;: end_condition, &#39;player1&#39;: self.player1}

    def gen_return(self, condition):
        &#34;&#34;&#34;Generates all 4 return objects.

        Args:
            condition: WIN or LOSS

        Returns:
            The observation, the reward, whether the run is done, and the info.
        &#34;&#34;&#34;

        bonus = 10 if condition == WIN else 0
        done = bool(condition in (WIN, LOSE))
        return self.gen_obs(condition), bonus, done, self.gen_info(condition)

    # def gen_score(self):
    #     &#34;&#34;&#34;Generates a reward to return.
    #     &#34;&#34;&#34;
    #     # Hand value calculation
    #     # hand_value = sum([dank_float_order(card, self.dank) for card in self.model.hand])
    #     # hand_value = hand_value / (len(self.model.hand) + 1) * 8
    #     # # Punishes for excessive taking.
    #     # taking_reward = 2 / 3.1415 * 3.5 * atan(4 - self.takes)
    #
    #     return 0

    def reset(self):
        &#34;&#34;&#34;Resets the game to the starting state.
        &#34;&#34;&#34;

        self.game_started = False
        self.deck = Deck()
        self.out_pile = []
        self.players = []
        self.turns = 0
        self.table = []
        self.ranks = {}
        self.attack_count = 0
        self.state = None
        self.dank = None
        self.table_card = None
        self.opponent = random.choice(self.strategies)
        self.first_shed = True
        self.shed_so_far = None
        self.allowed_to_shed = None
        self.model = Model()
        self.legal_moves = 0
        self.successful_attacks = 0
        self.successful_defenses = 0
        self.takes = 0
        self.player1 = True

    def render(self, mode=&#39;human&#39;):
        &#34;&#34;&#34;Will not be used.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gym.core.Env</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="durak_env.DurakEnv.add_attack"><code class="name flex">
<span>def <span class="ident">add_attack</span></span>(<span>self, card)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds card to the table and updates ranks.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><a title="card" href="card.html"><code>card</code></a></strong></dt>
<dd>Card to be added to the table</dd>
</dl>
<p>Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_attack(self, card):
    &#34;&#34;&#34;Adds card to the table and updates ranks.

    Args:
        card: Card to be added to the table

    Returns:
    &#34;&#34;&#34;

    self.table.append(card)
    self.ranks[card.rank] = 0
    self.attack_count += 1</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.clear_table"><code class="name flex">
<span>def <span class="ident">clear_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Method to clean up variables related to the table.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_table(self):
    &#34;&#34;&#34;Method to clean up variables related to the table.
    &#34;&#34;&#34;

    self.out_pile += self.table
    self.table = []
    self.ranks = {}
    self.attack_count = 0</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.gen_info"><code class="name flex">
<span>def <span class="ident">gen_info</span></span>(<span>self, condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates info to return.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>WIN, LOSE, or CONTINUE.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>number</code> of <code>takes</code>, <code>legal</code> <code>moves</code>, <code>successful</code> <code>attacks</code> <code>and</code> <code>defends</code>,</dt>
<dd>&nbsp;</dd>
</dl>
<p>and the end condition.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_info(self, condition):
    &#34;&#34;&#34;Generates info to return.

    Args:
        condition: WIN, LOSE, or CONTINUE.

    Returns:
        The number of takes, legal moves, successful attacks and defends,
        and the end condition.
    &#34;&#34;&#34;

    if condition == WIN:
        end_condition = &#39;WIN&#39;
    elif condition == LOSE:
        end_condition = &#39;LOSE&#39;
    else:
        end_condition = &#39;N/A&#39;
    return {&#39;takes&#39;: self.takes, &#39;legal_moves&#39;: self.legal_moves, &#39;successful_attacks&#39;: self.successful_attacks, &#39;successful_defends&#39;: self.successful_defenses, &#39;end_condition&#39;: end_condition, &#39;player1&#39;: self.player1}</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.gen_legal_moves"><code class="name flex">
<span>def <span class="ident">gen_legal_moves</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a set of legal moves.</p>
<h2 id="returns">Returns</h2>
<p>Boolean vector of legal moves.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_legal_moves(self):
    &#34;&#34;&#34;Generates a set of legal moves.

    Returns:
        Boolean vector of legal moves.
    &#34;&#34;&#34;

    ret = [0] * 38
    if self.state == &#39;a&#39;:
        if len(self.table) != 0:
            ret[36] = 1
        for card in self.model.hand:
            if self.legal_attack(CARD_TO_OBS[card]):
                ret[CARD_TO_OBS[card]] = 1

    if self.state == &#39;d&#39;:
        ret[37] = 1
        for card in self.model.hand:
            if self.legal_defense(CARD_TO_OBS[card]):
                ret[CARD_TO_OBS[card]] = 1

    # legal_shed called AFTER
    if self.state == &#39;s&#39;:
        ret[36] = 1
        if self.first_shed:
            allowed_sheds = min(6 - self.attack_count, len(self.opponent))
            if allowed_sheds &gt; 0:
                for card in self.model.hand:
                    if card.rank in self.ranks:
                        ret[CARD_TO_OBS[card]] = 1
        else:
            if self.shed_so_far &lt; self.allowed_to_shed:
                for card in self.model.hand:
                    if card.rank in self.ranks:
                        ret[CARD_TO_OBS[card]] = 1

    return ret</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.gen_obs"><code class="name flex">
<span>def <span class="ident">gen_obs</span></span>(<span>self, condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates observations to send to the model.</p>
<h2 id="returns">Returns</h2>
<p>An observation based on game state.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_obs(self, condition):
    &#34;&#34;&#34;Generates observations to send to the model.

    Returns:
        An observation based on game state.
    &#34;&#34;&#34;
    if condition in (WIN, LOSE):
        return np.zeros(219, )
    # 0 if unknown.
    ret = [0] * 36
    # 1 if on table.
    for card in self.table:
        ret[CARD_TO_OBS[card]] = 1
    # 2 if in hand.
    for card in self.model.hand:
        ret[CARD_TO_OBS[card]] = 2

    # 3 if in out pile.
    for card in self.out_pile:
        ret[CARD_TO_OBS[card]] = 3

    # 4 if table card.
    ret[CARD_TO_OBS[self.table_card]] = 4
    ret2 = np.zeros(shape=(6, 36), )
    state = [0, 0, 0]
    if self.state == &#39;a&#39;:
        state[0] = 1
    elif self.state == &#39;s&#39;:
        state[1] = 1
    elif self.state == &#39;d&#39;:
        state[2] = 1
        last_card = self.table[-1]
        obs = CARD_TO_OBS[last_card]
        ret2[5][obs] = 1

    for index, value in enumerate(ret):
        ret2[value][index] = 1

    return np.concatenate((ret2.flatten(), state))</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.gen_return"><code class="name flex">
<span>def <span class="ident">gen_return</span></span>(<span>self, condition)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all 4 return objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>WIN or LOSS</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The observation, the reward, whether the run is done, and the info.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_return(self, condition):
    &#34;&#34;&#34;Generates all 4 return objects.

    Args:
        condition: WIN or LOSS

    Returns:
        The observation, the reward, whether the run is done, and the info.
    &#34;&#34;&#34;

    bonus = 10 if condition == WIN else 0
    done = bool(condition in (WIN, LOSE))
    return self.gen_obs(condition), bonus, done, self.gen_info(condition)</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.legal_attack"><code class="name flex">
<span>def <span class="ident">legal_attack</span></span>(<span>self, move)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines whether an attack is a legal action or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>move</code></strong></dt>
<dd>The attack to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if attack is legal, False otherwise.
Attack is legal if:
Move &lt; 36 or 108.
Card matches ranks in table.
Card is in hand.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legal_attack(self, move: int):
    &#34;&#34;&#34;Determines whether an attack is a legal action or not.

    Args:
        move: The attack to check.

    Returns:
        True if attack is legal, False otherwise.
            Attack is legal if:
            Move &lt; 36 or 108.
            Card matches ranks in table.
            Card is in hand.
    &#34;&#34;&#34;

    # Has chosen to play a card.
    if move &lt; 36:
        card = OPTIONS_DICT[move]
        if card in self.model.hand and (card.rank in self.ranks or len(self.table) == 0):
            return True
    # &#39;done&#39;
    elif move == 36:
        if len(self.table) != 0:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.legal_defense"><code class="name flex">
<span>def <span class="ident">legal_defense</span></span>(<span>self, move)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines whether a defense is a legal action or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>move</code></strong></dt>
<dd>The defense to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if defense is legal.
Defense is legal if it is higher rank same suit, or any dank, or
higher dank in the case that a dank was played.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legal_defense(self, move):
    &#34;&#34;&#34;Determines whether a defense is a legal action or not.

    Args:
        move: The defense to check.

    Returns:
        True if defense is legal.
            Defense is legal if it is higher rank same suit, or any dank, or
            higher dank in the case that a dank was played.
    &#34;&#34;&#34;

    if move == 37:
        # Take is always legal in defense.
        return True

    if move &lt; 36:
        # Made a defense move.
        card = OPTIONS_DICT[move]
        # Defend against attack.
        attack = self.table[-1]
        if card in self.model.hand:
            if card.suit == attack.suit and RANK_NUM[card.rank] &gt; RANK_NUM[attack.rank]:
                # Higher in same suit, dank or non.
                return True

            if attack.suit != self.dank and card.suit == self.dank:
                # Or defense is dank suit and attack is not.
                return True
    return False</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.legal_shed"><code class="name flex">
<span>def <span class="ident">legal_shed</span></span>(<span>self, move)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines whether a shed is a legal action or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>move</code></strong></dt>
<dd>The attack to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether or not the shed is legal.
'Done' is always a legal shed.
Shed card is legal if card is in hand and rank matches table.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def legal_shed(self, move):
    &#34;&#34;&#34;Determines whether a shed is a legal action or not.

    Args:
        move: The attack to check.

    Returns:
        Whether or not the shed is legal.
            &#39;Done&#39; is always a legal shed.
            Shed card is legal if card is in hand and rank matches table.
    &#34;&#34;&#34;

    # First shed state of the round.
    if self.first_shed:
        self.first_shed = False
        self.allowed_to_shed = min(6 - self.attack_count, len(self.opponent))
        self.shed_so_far = 0
    # Done is always legal during a shed.
    if move == 36:
        self.first_shed = True
        self.allowed_to_shed = -1
        return True

    # Shed action
    if move &lt; 36:
        card = OPTIONS_DICT[move]
        if card in self.model.hand and card.rank in self.ranks and self.shed_so_far &lt; self.allowed_to_shed:
            self.first_shed = False
            self.shed_so_far += 1
            return True

    return False</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.mandatory_opponent_attack"><code class="name flex">
<span>def <span class="ident">mandatory_opponent_attack</span></span>(<span>self, info)</span>
</code></dt>
<dd>
<section class="desc"><p>Bot's first attack and set state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>info</code></strong></dt>
<dd>Error message to raise</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mandatory_opponent_attack(self, info):
    &#34;&#34;&#34;Bot&#39;s first attack and set state.

    Args:
        info: Error message to raise
    &#34;&#34;&#34;

    atk = self.opponent.attack(self.table, self.ranks)
    if self.print_trace:
        print(&#39;Opponent starts attack with &#39; + str(atk[1]))
    if atk[0] != Attack.play:
        raise RuntimeError(info)
    self.add_attack(atk[1])
    self.state = &#39;d&#39;
    del atk</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.player_draw"><code class="name flex">
<span>def <span class="ident">player_draw</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<section class="desc"><p>Players draw and report win condition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><a title="player" href="player.html"><code>player</code></a></strong></dt>
<dd>Model or Player.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if player is out of cards after draw, False otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def player_draw(self, player):
    &#34;&#34;&#34; Players draw and report win condition.

    Args:
        player: Model or Player.

    Returns:
        True if player is out of cards after draw, False otherwise.
    &#34;&#34;&#34;

    if len(player) &lt; 6:
        for _ in range(6 - len(player)):
            player.take(self.deck.draw())
        if len(player) == 0:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, mode='human')</span>
</code></dt>
<dd>
<section class="desc"><p>Will not be used.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, mode=&#39;human&#39;):
    &#34;&#34;&#34;Will not be used.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Resets the game to the starting state.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Resets the game to the starting state.
    &#34;&#34;&#34;

    self.game_started = False
    self.deck = Deck()
    self.out_pile = []
    self.players = []
    self.turns = 0
    self.table = []
    self.ranks = {}
    self.attack_count = 0
    self.state = None
    self.dank = None
    self.table_card = None
    self.opponent = random.choice(self.strategies)
    self.first_shed = True
    self.shed_so_far = None
    self.allowed_to_shed = None
    self.model = Model()
    self.legal_moves = 0
    self.successful_attacks = 0
    self.successful_defenses = 0
    self.takes = 0
    self.player1 = True</code></pre>
</details>
</dd>
<dt id="durak_env.DurakEnv.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<section class="desc"><p>Proceeds through a single step in the game.</p>
<p>Goes from one state of the game to the next based on the input action
that it receives and returns relevant information.
detail.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong></dt>
<dd>The action to take on this step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>representation</code> of <code>the</code> <code>current</code> <code>state</code> of <code>the</code> <a title="game" href="game.html"><code>game</code></a>,</dt>
<dd>&nbsp;</dd>
<dt><code>a</code> <code>representation</code> <code>ofs</code> <code>the</code> <code>fitness</code> of <code>this</code> <code>genome</code>,</dt>
<dd>&nbsp;</dd>
<dt><code>a</code> <code>representation</code> of <code>whether</code> or <code>not</code> <code>the</code> <a title="game" href="game.html"><code>game</code></a> <code>is</code> <code>done</code>,</dt>
<dd>&nbsp;</dd>
</dl>
<p>additional information that may be useful.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, action: list):
    &#34;&#34;&#34;Proceeds through a single step in the game.

    Goes from one state of the game to the next based on the input action
    that it receives and returns relevant information.
    detail.

    Args:
        action: The action to take on this step.

    Returns:
        A representation of the current state of the game,
        a representation ofs the fitness of this genome,
        a representation of whether or not the game is done,
        additional information that may be useful.
    &#34;&#34;&#34;

    if not self.game_started:
        self.game_started = True
        self.deck.shuffle_deck()
        # Deal cards.
        for _ in range(6):
            self.opponent.take(self.deck.draw())
            self.model.take(self.deck.draw())

        self.table_card = self.deck.flip()
        self.dank = self.table_card.suit
        self.opponent.dank = self.dank

        # AI attacks first.
        if action[0] &lt; .5:
            self.state = &#34;a&#34;
            logging.info(&#39;Model attacks first&#39;)
            return self.gen_return(CONTINUE)

        logging.info(&#39;bot attacks first&#39;)
        # Bot attacks first.
        self.mandatory_opponent_attack(info=&#34;Atk[0] != Attack.play, bot is not attacking at start.&#34;)
        return self.gen_return(CONTINUE)

    legal_moves = self.gen_legal_moves()

    filtered = np.multiply(np.array(legal_moves), np.abs((np.array(action)) + .01))

    filtered_action = int(np.argmax(filtered))
    assert isinstance(filtered_action, int)
    move = OPTIONS_DICT[filtered_action]
    self.legal_moves += 1
    if self.state == &#39;a&#39;:
        if self.legal_attack(filtered_action):
            # AI plays a card.
            if isinstance(move, Card):
                self.model.remove_card(move)
                self.add_attack(move)
                defense = self.opponent.defend(self.table, False, 1)
                # Both players still have cards or drawing potential.
                logging.info(defense[0])
                if defense[0] == Defense.defend:
                    self.table += defense[1]
                    self.ranks.update({card.rank: 0 for card in defense[1]})
                    logging.info(&#39;Table object: %s&#39;, &#39;, &#39;.join([str(x) for x in self.table]))
                    # Check for end of turn conditions.
                    if len(self.table) == 12 or len(self.model) == 0 or len(self.opponent) == 0:
                        # Turn is over, reset table.
                        self.clear_table()

                        # Draw cards, attacker then defender
                        if self.player_draw(self.model):
                            # Model wins on attack.
                            return self.gen_return(WIN)

                        if self.player_draw(self.opponent):
                            # Bot wins defending in attack phase.
                            return self.gen_return(LOSE)

                        # Bot attacks table.
                        self.mandatory_opponent_attack(&#39;Opponent is not attacking on first attack after turn end&#39;)
                        return self.gen_return(CONTINUE)
                    # Turn is not over, Model is attacking again
                    self.state = &#39;a&#39;
                    return self.gen_return(CONTINUE)
                if defense[0] == Defense.take:
                    self.state = &#39;s&#39;  # Model will be shedding in next step
                    if self.print_trace:
                        print(&#39;Opponent has chosen to take&#39;)
                    self.successful_attacks += 1
                    return self.gen_return(CONTINUE)
                raise RuntimeError(&#39;Opponent has passed cards&#39;)
            if move == &#39;done&#39;:  # AI is done in attack context
                self.clear_table()
                # Bot attacks table.
                if self.player_draw(self.model):
                    # MODEL win, impossible condition.
                    raise RuntimeError(&#34;Win condition: Model won during done&#34;)
                if self.player_draw(self.opponent):
                    # Opponent win, impossible condition.
                    raise RuntimeError(&#34;Win condition: Opponent won during done&#34;)
                self.mandatory_opponent_attack(&#39;Opponent is not attacking on first attack.&#39;)
                logging.info(&#39;Bot attack after done&#39;)
                logging.info(&#39; &#39;.join([str(x) for x in self.table]))
                # Model will be defending next turn.
                return self.gen_return(CONTINUE)
            raise RuntimeError(&#39;Legal_attack true but not attack or move.&#39;)
        # Punish and end.
        logging.error(&#39;Model has played illegal move&#39;)
        logging.error(str(move))
        logging.error(&#39;move %s&#39;, move)
        logging.error(&#39;filtered actions: %s&#39;, filtered)
        logging.info(&#39;legal_attack %s&#39;, self.legal_attack(filtered_action))
        raise RuntimeError(&#34;Model made an illegal move&#34;)
    # Defend state logic.
    if self.state == &#34;d&#34;:
        # Bot has already attacked.
        if self.legal_defense(filtered_action):
            if isinstance(move, Card):
                self.table.append(move)
                self.model.remove_card(move)
                if len(self.table) == 12 or len(self.model) == 0 or len(self.opponent) == 0:
                    # Turn is over
                    self.clear_table()
                    # Draw cards, attacker (opponent) then defender (model)
                    if self.player_draw(self.opponent):
                        # Bot wins defending in attack phase.
                        return self.gen_return(LOSE)
                    if self.player_draw(self.model):
                        # Model wins on attack.
                        return self.gen_return(WIN)
                    # If game hasn&#39;t ended, the turn is over and the bot successfully defends.
                    self.state = &#34;a&#34;
                    return self.gen_return(CONTINUE)

                atk = self.opponent.attack(self.table, self.ranks)
                logging.info(atk[0])
                if atk[0] == Attack.play:
                    self.add_attack(atk[1])
                    self.state = &#39;d&#39;
                    return self.gen_return(CONTINUE)

                if atk[0] == Attack.done:
                    self.clear_table()
                    # Players get to draw, attacker first.
                    # It shouldn&#39;t be possible for a win condition here.
                    if self.player_draw(self.opponent):
                        raise RuntimeError(&#39;Win condition in defense phase:\nOpponent has won after ceasing attack.&#39;)

                    if self.player_draw(self.model):
                        raise RuntimeError(&#39;Win condition in defense phase:\nModel has won after ceasing attack.&#39;)

                    self.successful_defenses += 1
                    self.state = &#39;a&#39;
                else:

                    raise RuntimeError(&#39;In defense phase, opponent has not chosen play or done.&#39;)

            elif move == &#39;take&#39;:
                # Bot gets to shed.
                self.takes += 1
                shed = self.opponent.shed(self.table, min((6 - self.attack_count, len(self.model))), self.ranks)
                if self.print_trace:
                    print(&#34;opponent sheds: &#34; + &#34;, &#34;.join([str(x) for x in shed]))

                if self.player_draw(self.opponent):
                    # Opponent has won on their shed.
                    return self.gen_return(LOSE)

                self.table += shed
                self.model.take_table(self.table)
                # self.table = [] before clear table to prevent out pile duplicate.
                self.table = []
                self.clear_table()

                # Get Bot Attack.
                self.mandatory_opponent_attack(&#39;opponent is not attacking on first attack&#39;)
            else:
                raise RuntimeError(&#39;legal_defense true but not defense or take: move = {}&#39;.format(str(move)))
        else:
            # Return and punish.
            logging.error(&#39;Model has played illegal move&#39;)
            logging.error(str(move))
            logging.error(&#39;move %s&#39;, move)
            logging.error(&#39;filtered actions: %s&#39;, filtered)
            logging.error(&#39;action %s&#39;, filtered_action)
            logging.info(&#39;legal_Defense %s&#39;, self.legal_defense(filtered_action))
            raise RuntimeError(&#34;Model made an illegal move&#34;)

    # Shed state logic.
    elif self.state == &#34;s&#34;:
        logging.info(&#39;state s&#39;)
        if self.legal_shed(filtered_action):
            if isinstance(move, Card):
                # Shed 1 card -&gt; return to shed.
                self.model.remove_card(move)
                self.add_attack(move)
                self.state = &#39;s&#39;
            elif move == &#39;done&#39;:
                # Done -&gt; attack.
                self.first_shed = True
                self.opponent.take_table(self.table)

                # self.table = [] before clear table to prevent duplicates in out pile
                self.table = []
                self.clear_table()
                self.state = &#39;a&#39;

                # Check win condition / draw.
                # Opponent shouldn&#39;t have to draw here.
                if self.player_draw(self.model):
                    # Model has won by shedding last cards.
                    return self.gen_return(WIN)
                return self.gen_return(CONTINUE)

            else:
                logging.info(&#39;move %s&#39;, move)
                logging.info(&#39;action %s&#39;, filtered_action)
                raise RuntimeError(&#39;legal_shed true but not shed or done&#39;)
        else:
            logging.error(&#39;Model has played illegal move&#39;)
            logging.error(&#39;Dank %s: &#39;, self.dank)
            logging.error(&#39;Attack Count: %s &#39;, str(self.attack_count))
            logging.error(&#39;shed so far %s &#39;, str(self.shed_so_far))
            logging.error(&#39;Table: %s&#39;, str([str(x) for x in self.table]))
            logging.error(&#39;Hand: %s&#39;, str([str(x) for x in self.model.hand]))
            logging.error(&#39;len opponent %s&#39;, str(len(self.opponent)))
            logging.error(str(move))
            logging.error(&#39;move %s&#39;, move)
            logging.error(&#39;filtered actions: %s&#39;, list(filtered))
            logging.info(&#39;legal_attack %s&#39;, self.legal_attack(filtered_action))
            raise RuntimeError(&#34;Model made an illegal move&#34;)

    logging.info(&#34;%s&#34;, self.state)

    return self.gen_return(CONTINUE)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="durak_env.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
</code></dt>
<dd>
<section class="desc"><p>Model is a wrapper for the AI hand.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>hand</code></strong></dt>
<dd>The cards in the model's hand.</dd>
</dl>
<p>Inits Model.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model:
    &#34;&#34;&#34;Model is a wrapper for the AI hand.

        Attributes:
            hand: The cards in the model&#39;s hand.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Inits Model.
        &#34;&#34;&#34;

        self.hand = []

    def __len__(self):
        return len(self.hand)

    def take(self, card):
        &#34;&#34;&#34;Adds card to the model&#39;s hand.

        Args:
            card: The card to add to the hand.
        &#34;&#34;&#34;

        if card is not None:
            self.hand.append(card)

    def take_table(self, cards):
        &#34;&#34;&#34;Adds cards to the model&#39;s hand.

        Args:
            cards: The list of cards to add to the model&#39;s hand.
        &#34;&#34;&#34;

        self.hand += cards

    def remove_card(self, card):
        &#34;&#34;&#34;Removes a card from the model&#39;s hand.

        Args:
            card: The card to remove from the model&#39;s hand.
        &#34;&#34;&#34;

        self.hand.remove(card)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="durak_env.Model.remove_card"><code class="name flex">
<span>def <span class="ident">remove_card</span></span>(<span>self, card)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes a card from the model's hand.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><a title="card" href="card.html"><code>card</code></a></strong></dt>
<dd>The card to remove from the model's hand.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_card(self, card):
    &#34;&#34;&#34;Removes a card from the model&#39;s hand.

    Args:
        card: The card to remove from the model&#39;s hand.
    &#34;&#34;&#34;

    self.hand.remove(card)</code></pre>
</details>
</dd>
<dt id="durak_env.Model.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, card)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds card to the model's hand.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><a title="card" href="card.html"><code>card</code></a></strong></dt>
<dd>The card to add to the hand.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(self, card):
    &#34;&#34;&#34;Adds card to the model&#39;s hand.

    Args:
        card: The card to add to the hand.
    &#34;&#34;&#34;

    if card is not None:
        self.hand.append(card)</code></pre>
</details>
</dd>
<dt id="durak_env.Model.take_table"><code class="name flex">
<span>def <span class="ident">take_table</span></span>(<span>self, cards)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds cards to the model's hand.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cards</code></strong></dt>
<dd>The list of cards to add to the model's hand.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_table(self, cards):
    &#34;&#34;&#34;Adds cards to the model&#39;s hand.

    Args:
        cards: The list of cards to add to the model&#39;s hand.
    &#34;&#34;&#34;

    self.hand += cards</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="durak_env.DurakEnv" href="#durak_env.DurakEnv">DurakEnv</a></code></h4>
<ul class="">
<li><code><a title="durak_env.DurakEnv.add_attack" href="#durak_env.DurakEnv.add_attack">add_attack</a></code></li>
<li><code><a title="durak_env.DurakEnv.clear_table" href="#durak_env.DurakEnv.clear_table">clear_table</a></code></li>
<li><code><a title="durak_env.DurakEnv.gen_info" href="#durak_env.DurakEnv.gen_info">gen_info</a></code></li>
<li><code><a title="durak_env.DurakEnv.gen_legal_moves" href="#durak_env.DurakEnv.gen_legal_moves">gen_legal_moves</a></code></li>
<li><code><a title="durak_env.DurakEnv.gen_obs" href="#durak_env.DurakEnv.gen_obs">gen_obs</a></code></li>
<li><code><a title="durak_env.DurakEnv.gen_return" href="#durak_env.DurakEnv.gen_return">gen_return</a></code></li>
<li><code><a title="durak_env.DurakEnv.legal_attack" href="#durak_env.DurakEnv.legal_attack">legal_attack</a></code></li>
<li><code><a title="durak_env.DurakEnv.legal_defense" href="#durak_env.DurakEnv.legal_defense">legal_defense</a></code></li>
<li><code><a title="durak_env.DurakEnv.legal_shed" href="#durak_env.DurakEnv.legal_shed">legal_shed</a></code></li>
<li><code><a title="durak_env.DurakEnv.mandatory_opponent_attack" href="#durak_env.DurakEnv.mandatory_opponent_attack">mandatory_opponent_attack</a></code></li>
<li><code><a title="durak_env.DurakEnv.player_draw" href="#durak_env.DurakEnv.player_draw">player_draw</a></code></li>
<li><code><a title="durak_env.DurakEnv.render" href="#durak_env.DurakEnv.render">render</a></code></li>
<li><code><a title="durak_env.DurakEnv.reset" href="#durak_env.DurakEnv.reset">reset</a></code></li>
<li><code><a title="durak_env.DurakEnv.step" href="#durak_env.DurakEnv.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="durak_env.Model" href="#durak_env.Model">Model</a></code></h4>
<ul class="">
<li><code><a title="durak_env.Model.remove_card" href="#durak_env.Model.remove_card">remove_card</a></code></li>
<li><code><a title="durak_env.Model.take" href="#durak_env.Model.take">take</a></code></li>
<li><code><a title="durak_env.Model.take_table" href="#durak_env.Model.take_table">take_table</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>